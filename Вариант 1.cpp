/*******************************************************************************
 * Л А Б О Р А Т О Р Н А Я   Р А Б О Т А  №2  З А   2   С Е М Е С Т Р   С  +  +*
 *-----------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                   *
 * Project Name  : Двумерные массивы                                           *
 * File Name     : Вариант1.CPP                                                *
 * Programmer(s) : Викулов Д.Г.                                                *
 * Modifyed By   :                                                             *
 * Created       : 22/04/22                                                    *
 * Last Revision : 04/05/22                                                    *
 * Comment(s)    : Получает на вход из файла параметры массива и его           *
 *                 составляющие. Сначала ищет количество строк, не содержащих  *
 *                 ни одного чётного элемента. Затем определяет максимальное   *
 *                 из чисел, встречающихся в матрице более одного раза.        *
 *                 Используем динамическую память.                             *
 *******************************************************************************/

#include <iostream>    // стандартные потоки ввода/вывода
#include <fstream>     // файловые потоки ввода/вывода
using namespace std;   // используем пространство имён std


/*******************************************************************/
/*                    Н А Б О Р    Т Е С Т О В                     */
/*******************************************************************/
//ДЛЯ МАТРИЦЫ А
//const char* FNAME = "Faila_net.txt";      //путь к файлу через константный указатель
//const char* FNAME = "Pustota.txt";
//const char* FNAME = "rN_ne_chislo.txt";
//const char* FNAME = "rN_Less_0.txt";
//const char* FNAME = "rM_ne_chislo.txt";
//const char* FNAME = "rM_Less_0.txt";
//const char* FNAME = "V_Massive_Ne_Chislo.txt";
//const char* FNAME = "Chislo_elementov_bigger_objavlennogo.txt";
//const char* FNAME = "Chislo_elementov_less_objavlennogo.txt";
//const char* FNAME = "Vse_po_odnomy.txt";
//const char* FNAME = "V_Massive_Vse_Stroki_Chet.txt";
const char* FNAME = "Vse_Verno.txt";

//ДЛЯ МАТРИЦЫ B

//const char* FNAMEB = "Faila_netB.txt";      //путь к файлу через константный указатель
//const char* FNAMEB = "PustotaB.txt";
//const char* FNAMEB = "rN_ne_chisloB.txt";
//const char* FNAMEB = "rN_Less_0B.txt";
//const char* FNAMEB = "rM_ne_chisloB.txt";
//const char* FNAMEB = "rM_Less_0B.txt";
//const char* FNAMEB = "V_Massive_Ne_ChisloB.txt";
//const char* FNAMEB = "Chislo_elementov_bigger_objavlennogoB.txt";
//const char* FNAMEB = "Chislo_elementov_less_objavlennogoB.txt";
//const char* FNAMEB = "Vse_po_odnomyB.txt";
//const char* FNAMEB = "V_Massive_Vse_Stroki_ChetB.txt";
const char* FNAMEB = "Vse_VernoB.txt";

/***************************************************************/
/*          П Р О Т О Т И П Ы    Ф У Н К Ц И Й                 */
/***************************************************************/

// сообщения об ошибках
void PrintMessage(int xErrCode    // код ошибки
    , const char* FName);         // имя файла с ошибкой

// считывание и создание динамической матрицы из файла
int reading_matr(int*** ppMatr   // указатель главной матрицы для матрицы указателей
    , int* rN                     // реальное количество строк
    , int* rM                     // реальное количество столбцов
    , int& ErrNo                  // код ошибки
    , const char* FNAME);         // имя файла 

//печать матрицы
void PrintMatr(int** ppMatr       // указатель первого элемента матрицы указателей
    , int rN                      // реальное количество строк
    , int rM);                    // реальное количество столбцов

// поиск строк, не содержащих ни одного чётного
int kol_vo(int** ppMatr          // указатель на массив указателей
    , int rN                      // реальное количество строк
    , int rM                      // реальное количество столбцов
    , int& ErrNo);                // номер ошибки

// поиск максимального из чисел, встречающихся более одного раза
int maxim(int** ppMatr           // указатель на массив указателей
    , int rN                     // реальное количество строк
    , int rM                     // реальное количество столбцов
    , int& ErrNo);               // код ошибки            

// создание динамического вектора из чисел матрицы
void sozdanie(int** ppMatr       // указатель на массив указателей
    , int** pVec                 // адрес указателя на динамический вектор
    , int rN                     // реальное количество строк
    , int rM                     // реальное количество столбцов
    , int lenVec);               // длина динамического вектора

//печать вектора
void PrintVec(int* pVec          // указатель на динамический вектор
    , int lenVec);               // длина динамического вектора

// сортировка вектора-массива по возрастанию
int sort(int* pVec[]             // адрес указателя на динамический вектор
    , int lenVec);               // длина динамического вектора

//освободить память вектора
void ReleaseVec(int* pVec);      // указатель на динамический вектор

//освободить память матрицы
void ReleaseMatr(int** ppMatr    // указатель на массив указателей
    , int rN);                   // реальное количество строк


/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/

int main()
{
    system("color F0");                        // делаем консоль светлой
    setlocale(LC_ALL, "Rus");                  // подключаем русский язык
    system("cls");                             // чистим консоль перед выводом
    int rN;                                   // реальное количество строк
    int rM;                                   // реальное количество столбцов
    int ErrNo = 0;                             // код ошибки
    int** ppMatrA = 0;                         // указатель на матрицу указателей. Записываем 0, чтобы указатель не был диким
    int** ppMatrB = 0;                          // указатель на матрицу указателей. Записываем 0, чтобы указатель не был диким

    // вызов функции 
    reading_matr(&ppMatrA, &rN, &rM, ErrNo, FNAME);    // т.к в прототипе указатели, то передаём адреса
    if (ErrNo == 0)                                    // ошибок нет
    {
        PrintMatr(ppMatrA, rN, rM);				       //печать матрицы из процедуры
        int stroki = kol_vo(ppMatrA, rN, rM, ErrNo);   // переменная, отвечающая за количество строк с нечётными элементами. Передаём значения ppMAtrA, rN и rM, т.к не надо их менять
        cout << "Количество строк, не содержащих ни одного чётного элемента: " << stroki << endl;
        int maximum = maxim(ppMatrA, rN, rM, ErrNo);   // переменная, отвечающая за максимальное число, встречающееся более одного раза. /........./
        ReleaseMatr(ppMatrA, rN);                      // удаляем выделенную динамическую память
    }
    // есть ошибка в файле
    else
    {
        PrintMessage(ErrNo, FNAME);                    // печатаем сведения об ошибке
    } // if
    if (ErrNo == 7 || ErrNo == 10)
    {
        PrintMessage(ErrNo, FNAME);                   // печатаем сведения о файле (фактически, не является проверкой на ошибку)
    } //if

    ErrNo = 0;                                        // Обнуляем, чтобы искать ошибки в матрице В
    // для матрицы B
    cout << "\n\n\t\t\t РАБОТАЕМ С МАТРИЦЕЙ B: \n";

    // вызов функции 
    reading_matr(&ppMatrB, &rN, &rM, ErrNo, FNAMEB);  // т.к в прототипе указатели, то передаём адреса
    if (ErrNo == 0)                                   // ошибок нет
    {
        PrintMatr(ppMatrB, rN, rM);				      //печать матрицы из процедуры
        int stroki = kol_vo(ppMatrB, rN, rM, ErrNo);  // переменная, отвечающая за количество строк с нечётными элементами. Передаём значения ppMatrB, rN и rM, т.к не надо их менять
        cout << "Количество строк, не содержащих ни одного чётного элемента: " << stroki << endl;
        int maximum = maxim(ppMatrB, rN, rM, ErrNo);  // переменная, отвечающая за максимальное число, встречающееся более одного раза. /........./
        ReleaseMatr(ppMatrB, rN);
    }
    // есть ошибка в файле
    else
    {
        PrintMessage(ErrNo, FNAMEB);                   // печатаем сведения об ошибке
    } //if
    if (ErrNo == 7 || ErrNo == 10)
    {
        PrintMessage(ErrNo, FNAMEB);                  // печатаем сведения о файле (фактически, не является проверкой на ошибку)
    } //if
    system("PAUSE");
    return (0);
} //main()

 /***************************************************/
 /*             РЕАЛИЗАЦИЯ ФУНКЦИЙ                  */
 /***************************************************/


 /*-------------------------------------------------*/
 /* чтение матрицы из файла */
 /*-------------------------*/
int  reading_matr(int*** ppMatr       // указатель главной матрицы для матрицы указателей
    , int* rN                         // указатель на реальное количество строк
    , int* rM                         // указатель на реальное количество столбцов
    , int& ErrNo                      // код ошибки
    , const char* FNAME)              // имя файла 
{
    int CountLine = 0;                // счётчик по строкам
    int CountColumn = 0;              // счётчик по столбцам
    int i = 0;                        // счётчик
    ifstream fin;                     // объявление объекта для потокового введения данных из файла
    fin.open(FNAME);                  // связываем обЪект с файлом. Открываем для чтения
    if (!fin.is_open())               //файл не найден
    {
        ErrNo = 1;
        fin.close();                  // закрыть файл
        return 1;                     // возвращаем значение, соответствующее типу
    }// if

    if (fin.peek() == EOF)            // файл пуст
    {
        ErrNo = 2;
        fin.close();                  // закрыть файл
        return 2;                     // возвращаем значение, соответствующее типу
    }// if

    fin >> *rN;                       // считываем количество строк (число *rN, а не указатель rN)
    fin >> *rM;                       // считываем количество столбцов (число *rM, а не указатель rM)

    if (fin.fail())                   // в файле не число (прочитали две первых строки - заметили несоответствие типов)
    {
        ErrNo = 3;
        fin.close();                  // закрыть файл
        return 3;                     // возвращаем значение, соответствующее типу
    }// if

    cout << "Исходные данные матрицы: \n";
    cout << "Количество строк: " << *rN << endl;
    cout << "Количество столбцов: " << *rM << endl;

    if (*rN < 0)                      // значение указателя отрицательно
    {

        ErrNo = 8;
        fin.close();                  // закрыть файл
        return 4;                     // возвращаем значение, соответствующее типу
    }// if

    if (*rM < 0)                      // значение указателя отрицательно
    {
        ErrNo = 9;
        fin.close();                  // закрыть файл
        return 4;                     // возвращаем значение, соответствующее типу
    }// if

    *ppMatr = new int* [*rN];          // создаём динамическую матрицу из указателей на строки с учётом того, что мы передавали указатель в функцию. Их rN штук
    for (i = 0; i < *rN; i++)         //выделение памяти под каждый элемент строки конкретной длины  
    {

        (*ppMatr)[i] = new int[*rM];  // на каждую строку матрицы указателей выделяем  динамический массив длиной rM
    }

    i = 0;                            // обнуляем счётчик
    while (!fin.eof())                             // пока не дошли до коца файла
    {
        if (i >= (*rN * *rM))                       // реальное количество больше объявленного
        {
            //вызов функции с ФАКТИЧЕСКИМИ параметрами
            ErrNo = 5;
            fin.close();                           // закрыть файл
            return 6;                              // возвращаем значение, соответствующее типу
        }// if
        fin >> (*ppMatr)[CountLine][CountColumn];  // считали элемент, поместили его на место pmatr[CountLine][CountColumn]. С учётом ПЕРЕДАЧИ УКАЗАТЕЛЯ В ФУНКЦИЮ
        CountColumn = CountColumn + 1;             // перешли к следующему столбцу


        if (CountColumn == *rM)                    // если достигли конца строки
        {
            CountLine = CountLine + 1;             // переходим к другой строке
            CountColumn = 0;                       // становимся на начало строки
        }//if

        if (fin.fail())                            // проверка на нечисло в самом массиве (на соответствие типов данных)
        {
            ErrNo = 4;
            fin.close();                           // закрыть файл
            return 5;                              // возвращаем значение, соответствующее типу
        }// if
        i = i + 1;                                 // увеличили счётчик
 
    }// while 
    if (i < (*rN * *rM))                           // реальное количество элементов меньше объявленного
    {
        //вызов функции с ФАКТИЧЕСКИМИ параметрами
        ErrNo = 6;
        fin.close();                               // закрыть файл
        return 7;                                  // возвращаем значение, соответствующее типу
    }// if

    fin.close();                                   // закрыть файл

    return 0;                                      // возвращаем значение, соответствующее типу, если всё хорошо
}// reading_matr()


/*-------------------------------------------------------------*/
/* Печать матрицы  */
/*-----------------*/
void PrintMatr(int** ppMatr                       // указатель первого элемента матрицы указателей
    , int rN                                      // реальное количество строк
    , int rM)                                     // реальное количество столбцов
{
    int i;                                        // счётчики
    int j;
    cout << "\n\n Считанная матрица: \n\n";
    for (i = 0; i < rN; i++)                      // идем до всем строкам
    {
        for (j = 0; j < rM; j++)                  // идём по каждому столбцу
        {
            cout << *(*(ppMatr + i) + j) << "  "; // печатаем элемент, используя арифметику указателей
        }// for j
        cout << "\n";
    }//for i
} // PrintMatr()


 /*-------------------------------------------------*/
 /*  количество строк      */
 /* с нечётными элементами */
 /*------------------------*/
int kol_vo(int** ppMatr                          // указатель первого элемента матрицы указателей
    , int rN                                     // фактическое значение реального количества строк
    , int rM                                     // фактическое значение реального количества столбцов
    , int& ErrNo)                                // номер ошибки
{
    int counter = 0;                             // счётчик
    bool chet = true;                            // флаг для поиска строки
    int k = 0;                                   // счётчик
    int i = 0;                                   // счётчик
    int j = 0;                                   // счётчик

    for (i = 0; i < rN; i++)                    // пока не дошли до последней строки
    {
        chet = true;                            // на каждой новой строке возвращаем флаг в исходное состояние
        for (j = 0; j < rM; j++)                // пока не дошли до последнего столбца
        {
            if (*(*(ppMatr + i) + j) % 2 == 0)  // если элемент строки чётный
            {
                chet = false;                   // строка не подходит
            }// if
        }// for
        if (chet)                               // нашли строку из нечётных элементов         
        {
            k++;                                // увеличили счётчик таких строк
        }// if
    }// for
    if (k == 0)                                 // нет таких строк
    {
        ErrNo = 10;
    }// if
    return k;                                  // вернули в caller наше нужное значение (количество искомых строк)
}// kol_vo()


 /*-------------------------------------------------*/
 /*  поиск максимального элемента,   */
 /*  который встречается не один раз */
 /*----------------------------------*/
int maxim(int** ppMatr                        // указатель первого элемента матрицы указателей
    , int rN                                  // реальное количество строк
    , int rM                                  // реальное количество столбцов
    , int& ErrNo)                             // код ошибки
{
    int i = 0;                                // счётчик
    int a = 0;                                // для запоминания такого элемента
    int j = 0;                                // счётчик
    int lenVec = rN * rM;                     // длина нового вектора
    int* vector = 0;                          // указатель на вектор-массив, созданный из элементов нашего многомерного
    sozdanie(ppMatr, &vector, rN, rM, lenVec);
    cout << "\n\t\t Считаный динамический вектор: \n\n";
    PrintVec(vector, lenVec);
    cout << "\n\n\t\t Сортировка выбором. Отстортированный массив: \n\n";
    //вызов функции 
    sort(&vector, lenVec);                    // передаём адрес, т.к в фунции стоит указатель на указатель на динамический массив, чтобы была возможность его менять    
    //вызов функции 
    PrintVec(vector, lenVec);
    for (i = lenVec - 1; i >= 0; i--)         // для всех элементов вектора, начиная с конца(для упрощения поиска максимального)
    {
        if (*(vector + i) == *(vector + (i - 1)))// если данный равен предыдущему (есть повторение элемента). Используем адресную арифметику
        {
            a = vector[i];                    // запоминаем этот элемент
            break;                            // выходим - нет смысла продолжать
        }// if
    }// for
    //вызов функции 
    ReleaseVec(vector);		                 // освобождение памяти. Передаём адрес первого элемента динамического массива

    if (a == 0)                              // все элементы различны(нет повторов)
    {
        //вызов функции с ФАКТИЧЕСКИМИ параметрами
        ErrNo = 7;
        return(8);                           // выходим, возвращая обещанный тип данных
    }// if

    cout << "\nМаксимальное из чисел, встречающихся в заданной матрице более одного раза: " << a << endl;
    return(0);                               // выходим без ошибки
}// maxim ()


/*-------------------------------------------------*/
/*  создание динамического */
/* вектора                 */
/*-------------------------*/
void  sozdanie(int** ppMatr                  // указатель на массив указателей
    , int** pVec                             // адрес указателя на динамический вектор
    , int rN                                 // реальное количество строк
    , int rM                                 // реальное количество столбцов
    , int lenVec)                            // длина динамического вектора
{
    int i = 0;                               // счётчик
    int j = 0;                               // счёткик
    int k = 0;                               // счётчик
    *pVec = new int[lenVec];                 // создаём динамический массив с учётом того, что передавался указатель
    for (i = 0; i < rN; i++)                 // пока не дошли до последный строки
    {
        for (j = 0; j < rM; j++)             // пока не дошли до последнего столбца
        {
            *(*pVec + k) = *(*(ppMatr + i) + j); // помещаем на данное место элемент многомерного массив
            k++;                               // переходим к следующему индексу
        }// for
    }// for
}// sozdsnie()


/*-------------------------------------------------------------*/
/* Печать вектора  */
/*-----------------*/
void PrintVec(int* pVec                        // указатель на динамический вектор
    , int lenVec)                              // длина динамического вектора
{
    int j = 0;                                 // счётчик
    for (j = 0; j < lenVec; j++)               // печатаем вектор
    {
        cout << "  " << *(pVec + j);           // используя арифметику указателей
    }
    cout << endl;
}// PrintVec()


 /*-------------------------------------------------*/
 /* сортировка вектора-массива выбором */
 /*------------------------------------*/
int sort(int* pVec[]                         // адрес указателя на динамический вектор
    , int lenVec)                            // длина вектра
{
    int Min;                                 // минимальный элемент
    int jMin;                                // индекс минимального элемента
    int iSort;                               // граница отсортированной области
    int i, j;                                // счётчики
    int Temp;                                // для перемещения

    for (iSort = 0; iSort < lenVec - 1; iSort++)   // пока не дошли до конца
    {
        // первый элемент из неупорядоченных назначаем минимальным. С УЧЁТОМ ПЕРЕДАЧИ УКАЗАТЕЛЯ в функцию
        Min = *(*pVec + iSort);                    // мимнимум
        jMin = iSort;                             // его индекс

        // ищем минимальный элемент в оставшейся части массива
        for (j = iSort + 1; j < lenVec; j++)
        {
            if (*(*pVec + j) < Min)               // очередной кандидат на минимальный
            {
                // запоминаем минимальный элемент и его номер
                Min = *(*pVec + j);
                jMin = j;
            }// if

        }// for j

        // нашли минимум в неупорядоченной части массива
        // ставим его на место первого в неупорядоченной части массива
        // меняем элементы местами
        Temp = *(*pVec + iSort);                 // Temp = (*pVec)[iSort];
        *(*pVec + iSort) = *(*pVec + jMin);      // (*pVec)[iSort] = (*pVec)[jMin];
        *(*pVec + jMin) = Temp;                  // (*pVec)[jMin] = Temp;

        //cout << "\n/2:\t";  // контрольная печать
        //for (int i = 0; i < lenVec; i++)
        //{
        //	cout << *pVec[i] << "\t";
        //}//for i
        //		cout << "\n";

    }// for iSort
    return(2);

}// sort ()


/*-------------------------------------------------------------*/
/* Удаление динамического вектора  */
/*---------------------------------*/
void ReleaseVec(int* pVec)                      // указатель на динамический вектор
{
    delete[] pVec;                              // удаление динамического массива
}// ReleaseVec()


/*-------------------------------------------------------------*/
/* Удаление динамической матрицы  */
/*--------------------------------*/
void ReleaseMatr(int** ppMatr                  // указатель на массив указателей
    , int rN)                                  // реальное количество строк
{
    int i;                                     // счётчик
    //освобождение памяти в обратном порядке
    for (i = 0; i < rN; i++)
    {
        delete[] ppMatr[i];                    // удаляем строки  (массивы)
    }// for i

    delete[] ppMatr;	                       // удаляем массив указателей на строки
}// ReleaseMatr()


 /*-------------------------------------------------*/
 /* сообщения об ошибках */
 /*----------------------*/
void PrintMessage(int xErrCode                 // код ошибки
    , const char* FNAME)                       // имя файла с ошибкой
{
    // расшифровка кода возврата в текст сообщения об ошибке
    switch (xErrCode)
    {
    case 1: cout << "/PrintMessage: Файл " << FNAME
        << " не найден;\n";
        break;
    case 2: cout << "Файл " << FNAME << " пустой;\n";
        break;
    case 3: cout << "В файле " << FNAME << " не число;\n";
        break;
    case 4: cout << "ОШИБКА!Среди элементов массива " << FNAME << " есть не число;\n";
        break;
    case 5: cout << "Вы ввели больше элементов в " << FNAME << ", чем вмещает массив;\n";
        break;
    case 6: cout << "Вы ввели меньше элементов в " << FNAME << ", чем указали;\n";
        break;
    case 7: cout << "В файле " << FNAME << " все элементы массива встречаются один раз;\n";
        break;
    case 8: cout << "В файле " << FNAME << " число строк матрицы отрицательно;\n";
        break;
    case 9: cout << "В файле " << FNAME << " число столбцов матрицы отрицательно;\n";
        break;
    case 10: cout << "В файле " << FNAME << " все строки содержат хотя бы один чётный элемент;\n";
        break;
    default:
        break;
    }// switch()

    return;                                // возврат значения соответственно типу
}// PrintMessage()